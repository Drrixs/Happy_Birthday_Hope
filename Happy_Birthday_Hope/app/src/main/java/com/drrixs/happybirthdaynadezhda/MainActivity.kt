//   [RU]
//   â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
//   ğŸŒŸ ĞŸÑ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ğ½Ğ¾ Ğ´Ğ»Ñ: t.me/@Albesus
//   ğŸ› ï¸ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ĞµĞ»ÑŒ ĞŸÑ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ: t.me/@Drrixs
//   â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
//   âš ï¸ Ğ’Ğ½Ğ¸Ğ¼Ğ°Ğ½Ğ¸Ğµ: ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ñ‹ Ğ¼Ğ¾Ğ³ÑƒÑ‚ ÑÑ‚Ğ°Ñ‚ÑŒ Ğ½ĞµĞ°ĞºÑ‚ÑƒĞ°Ğ»ÑŒĞ½Ñ‹Ğ¼Ğ¸ Ğ¸Ğ»Ğ¸ Ğ½ĞµĞ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¼Ğ¸ ÑĞ¾ Ğ²Ñ€ĞµĞ¼ĞµĞ½ĞµĞ¼.
//   ğŸ“¬ Ğ”Ğ»Ñ Ğ´Ğ¾Ğ»Ğ³Ğ¾ÑÑ€Ğ¾Ñ‡Ğ½Ğ¾Ğ¹ ÑĞ²ÑĞ·Ğ¸, Ğ²Ğ¾Ñ‚ Ğ¼Ğ¾Ğ¸ Ğ¿Ğ¾Ñ‡Ñ‚Ğ¾Ğ²Ñ‹Ğµ Ğ°Ğ´Ñ€ĞµÑĞ°:
//      ĞŸĞ¾Ñ‡Ñ‚Ğ° 1 - [Ğ°Ğ´Ñ€ĞµÑ]
//      ĞŸĞ¾Ñ‡Ñ‚Ğ° 2 - [Ğ°Ğ´Ñ€ĞµÑ]
//      ĞŸĞ¾Ñ‡Ñ‚Ğ° 3 - [Ğ°Ğ´Ñ€ĞµÑ]
//   ğŸ‘‰ Ğ ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´ÑƒĞµÑ‚ÑÑ Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒ Ğ½Ğ° Ğ²ÑĞµ ÑÑ€Ğ°Ğ·Ñƒ Ğ´Ğ»Ñ ÑƒĞ²ĞµÑ€ĞµĞ½Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ² Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞµ.
//   â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
//   [EN]
//   â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
//   ğŸŒŸ App Developed for: t.me/@Albesus
//   ğŸ› ï¸ App Creator: t.me/@Drrixs
//   â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
//   âš ï¸ Attention: Contacts may become outdated or invalid over time.
//   ğŸ“¬ For long-term communication, here are my email addresses:
//      Email 1 - [address]
//      Email 2 - [address]
//      Email 3 - [address]
//   ğŸ‘‰ It's recommended to write to all simultaneously to ensure delivery.
//   â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”


package com.drrixs.happybirthdaynadezhda

import android.app.AlarmManager
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.media.MediaPlayer
import android.os.Build
import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.widget.TextView
import androidx.appcompat.app.AppCompatActivity
import java.util.*
import android.util.Log
import android.view.animation.AnimationUtils
import android.widget.Toast
import android.provider.Settings
import androidx.core.app.NotificationCompat
import androidx.core.app.NotificationManagerCompat
import org.apache.commons.net.ntp.NTPUDPClient
import java.io.IOException
import java.util.Calendar
import java.net.InetAddress




class MainActivity : AppCompatActivity() {





    private lateinit var mediaPlayer: MediaPlayer



    private fun checkTimeManipulation() {
        val lastTimeUsed = prefs.getLong("LAST_TIME_USED", System.currentTimeMillis())
        val currentTime = System.currentTimeMillis()

        if (currentTime < lastTimeUsed) {
            Toast.makeText(this, "ĞĞ±Ğ½Ğ°Ñ€ÑƒĞ¶ĞµĞ½Ğ¾ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğµ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ½Ğ¾Ğ³Ğ¾ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ¸!", Toast.LENGTH_LONG).show()
        }

        prefs.edit().putLong("LAST_TIME_USED", currentTime).apply()
    }

    private lateinit var countdownTextView: TextView
    private val prefs by lazy { getSharedPreferences("APP_PREFERENCES", Context.MODE_PRIVATE) }
    private val handler = Handler(Looper.getMainLooper())
    private val updateRunnable = object : Runnable {
        override fun run() {
            val timeRemaining = (prefs.getLong("END_TIME", 0) - System.currentTimeMillis()) / 1000
            if (timeRemaining > 0) {
                countdownTextView.text = timeRemaining.toString()
                countdownTextView.startAnimation(AnimationUtils.loadAnimation(this@MainActivity, R.anim.fade_in))
                handler.postDelayed(this, 1000)
            } else {
                navigateToCountActivity()
            }
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {

        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        countdownTextView = findViewById(R.id.countdownTextView)
        val endTime = prefs.getLong("END_TIME", 0)
        val currentTime = System.currentTimeMillis()
        if (endTime > currentTime) {
            Log.d("MainActivity", "Setting alarm with existing end time")
            setAlarm(endTime)
        } else if (endTime == 0L) {
            Log.d("MainActivity", "Setting alarm with new end time")
            val targetDate = Calendar.getInstance().apply {
                set(Calendar.YEAR, 2023)
                set(Calendar.MONTH, Calendar.NOVEMBER)
                set(Calendar.DAY_OF_MONTH, 21)
                set(Calendar.HOUR_OF_DAY, 23)
                set(Calendar.MINUTE, 59)
                set(Calendar.SECOND, 0)
            }
            setAlarm(targetDate.timeInMillis)
        } else {
            Log.d("MainActivity", "Navigating to CountActivity")
            navigateToCountActivity()
        }
        mediaPlayer = MediaPlayer.create(this, R.raw.billie_eilish)


        mediaPlayer.start()

        checkTimeManipulation()




    }

    private fun setAlarm(targetTime: Long) {
        val alarmManager = getSystemService(Context.ALARM_SERVICE) as AlarmManager

        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.S) {
            if (!alarmManager.canScheduleExactAlarms()) {
                Toast.makeText(this, "Ğ Ğ°Ğ·Ñ€ĞµÑˆĞ¸ Ğ±ÑƒĞ´Ğ¸Ğ»ÑŒĞ½Ğ¸ĞºĞ¸ Ğ¸ Ğ½Ğ°Ğ¿Ğ¾Ğ¼Ğ¸Ğ½Ğ°Ğ½Ğ¸Ñ Ğ² Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ°Ñ…, ÑÑ‚Ğ¾ Ğ²Ğ°Ğ¶Ğ½Ğ¾!!!!", Toast.LENGTH_LONG).show()

                val intent = Intent(Settings.ACTION_REQUEST_SCHEDULE_EXACT_ALARM)
                startActivity(intent)
                return
            }
        }

        val intent = Intent(this, AlarmReceiver::class.java)
        val pendingIntentFlags = if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.M) {
            PendingIntent.FLAG_IMMUTABLE or 0
        } else {
            0
        }
        val pendingIntent = PendingIntent.getBroadcast(this, 0, intent, pendingIntentFlags)
        alarmManager.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, targetTime, pendingIntent)
        prefs.edit().putLong("END_TIME", targetTime).apply()
        val timeRemaining = (targetTime - System.currentTimeMillis()) / 1000
        countdownTextView.text = timeRemaining.toString()
        handler.post(updateRunnable)
    }

    class BootCompletedReceiver : BroadcastReceiver() {
        override fun onReceive(context: Context, intent: Intent) {
            if (intent.action == Intent.ACTION_BOOT_COMPLETED) {
                val prefs = context.getSharedPreferences("APP_PREFERENCES", Context.MODE_PRIVATE)
                val endTime = prefs.getLong("END_TIME", 0)
                val currentTime = System.currentTimeMillis()
                if (endTime > currentTime) {
                    val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager
                    val alarmIntent = Intent(context, AlarmReceiver::class.java)
                    val pendingIntentFlags = if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.M) {
                        PendingIntent.FLAG_IMMUTABLE or 0
                    } else {
                        0
                    }
                    val pendingIntent = PendingIntent.getBroadcast(context, 0, alarmIntent, pendingIntentFlags)
                    alarmManager.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, endTime, pendingIntent)
                }
            }
        }
    }

    class AlarmReceiver : BroadcastReceiver() {
        override fun onReceive(context: Context, intent: Intent) {

            val newIntent = Intent(context, CountActivity::class.java)
            newIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            context.startActivity(newIntent)
        }
    }

    private fun navigateToCountActivity() {
        val currentTime = System.currentTimeMillis()
        val endTime = prefs.getLong("END_TIME", 0)
        if (currentTime >= endTime) {
            val intent = Intent(this@MainActivity, CountActivity::class.java)
            intent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS)
            startActivity(intent)
            finish()
        } else {
        }
    }
}
